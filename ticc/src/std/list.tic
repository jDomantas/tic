import i from "std/intrinsics";
import option(Option, Some, None) from "std/option";
import (Result, Ok, Err) from "std/result";

export type List a = export Nil | Cons a rec;

export let map : (a -> b) -> List a -> List b =
    \f -> \fold list ->
        match list with
        | Nil -> Nil
        | Cons x xs -> Cons (f x) xs
        end;

export let filter : (a -> bool) -> List a -> List a =
    \f -> \fold list ->
        match list with
        | Nil -> Nil
        | Cons x xs -> if f x then Cons x xs else xs
        end;

export let sum : List int -> int =
    \fold list ->
        match list with
        | Nil -> 0
        | Cons x xs -> x + xs
        end;

export let any : List bool -> bool =
    \fold list ->
        match list with
        | Nil -> false
        | Cons x xs -> if x then true else xs
        end;

export let all : List bool -> bool =
    \fold list ->
        match list with
        | Nil -> true
        | Cons x xs -> if x then xs else false
        end;

export let head : List a -> Option a =
    \list ->
        match list with
        | Nil -> None
        | Cons x _ -> Some x
        end;

export let tail : List a -> Option (List a) =
    \list ->
        match list with
        | Nil -> None
        | Cons _ xs -> Some xs
        end;

export let reverse : List a -> List a =
    \list ->
        let go = \fold list -> \acc ->
            match list with
            | Nil -> acc
            | Cons x xs -> xs (Cons x acc)
            end;
        go list Nil;

export let max : List int -> Option int =
    \fold list ->
        match list with
        | Nil -> None
        | Cons x res ->
            match res with
            | None -> Some x
            | Some y ->
                if x > y then
                    Some x
                else
                    Some y
            end
        end;

export let min : List int -> Option int =
    \fold list ->
        match list with
        | Nil -> None
        | Cons x res ->
            match res with
            | None -> Some x
            | Some y ->
                if x < y then
                    Some x
                else
                    Some y
            end
        end;

export let maxBy : (a -> a -> bool) -> List a -> Option a =
    \less -> \fold list ->
        match list with
        | Nil -> None
        | Cons x res ->
            match res with
            | None -> Some x
            | Some y ->
                if less x y then
                    Some y
                else
                    Some x
            end
        end;

export let minBy : (a -> a -> bool) -> List a -> Option a =
    \less -> \fold list ->
        match list with
        | Nil -> None
        | Cons x res ->
            match res with
            | None -> Some x
            | Some y ->
                if less x y then
                    Some x
                else
                    Some y
            end
        end;

export let allSome : List (Option a) -> Option (List a) =
    \fold list ->
        match list with
        | Nil -> Some Nil
        | Cons x xs ->
            match x with
            | None -> None
            | Some x ->
                match xs with
                | None -> None
                | Some xs -> Some (Cons x xs)
                end
            end
        end;

export let allOk : List (Result a e) -> Result (List a) e =
    \fold list ->
        match list with
        | Nil -> Ok Nil
        | Cons x xs ->
            match x with
            | Err e -> Err e
            | Ok x ->
                match xs with
                | Err e -> Err e
                | Ok xs -> Ok (Cons x xs)
                end
            end
        end;

export let skip : int -> List a -> List a =
    \x -> \list ->
        let step = \l ->
            match l with
            | Nil -> Nil
            | Cons _ xs -> xs
            end;
        i.iterate x step list;

type TakeState a = TakeState (List a) (List a);

export let take : int -> List a -> List a =
    \x -> \list ->
        let step = \state ->
            match state with
            | TakeState a b ->
                match b with
                | Nil -> TakeState a b
                | Cons x xs -> TakeState (Cons x a) xs
                end
            end;
        match i.iterate x step (TakeState Nil list) with
        | TakeState a _ -> reverse a
        end;

export let length : List a -> int =
    \fold list ->
        match list with
        | Nil -> 0
        | Cons _ xs -> 1 + xs
        end;

export let foldr : (a -> b -> b) -> b -> List a -> b =
    \f -> \init -> \fold list ->
        match list with
        | Nil -> init
        | Cons x xs -> f x xs
        end;

export let foldl : b -> (b -> a -> b) -> List a -> b =
    \init -> \f -> \list -> foldr (\item -> \acc -> f acc item) init (reverse list);
